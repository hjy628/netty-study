1.堆缓冲区
    最常用的，将数据存储在JVM的堆空间中。这种模式被成为支撑数组(backing array),它能在没有使用池话的情况下提供快速的分配和释放，

2.直接缓冲区
    NIO在JDK1.4中引入的ByteBuffer类允许JVM实现通过本地调用来分配内存，主要是为了避免在每次调用本地I/O操作之前（或之后）将缓冲区的内容复制到一个中间缓冲区
    （或者从中间缓冲区把内容复制到缓冲区）
    直接缓冲区的主要缺点是，相对于基于堆的缓冲区，他们的分配和释放都较为昂贵

3.复合缓冲区
    它为多个ByteBuf提供一个聚合视图.在这里你可以根据需要添加或者删除ByteBuf实例，这是一个JDK的ByteBuffer实现完全缺失的特性
    Netty通过一个ByteBuf子类-CompositeByteBuf-实现了这个模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示
    CompositeByteBuf中的ByteBuf实例可能同时包含直接内存分配和非直接内存分配。如果其中只有一个实例，那么对CompositeByteBuf上的
    hasArray()方法的调用将返回该组件上的hasArray()方法的值，否则它将返回false